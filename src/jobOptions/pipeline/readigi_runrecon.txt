//
// Job Option file for readigi_runrecon:
// Read in a digi Root file and run recon on it!
//

//
// Things to be changed by the user can 
// be found at the end of the file!
//



//
// Primary DLLs, including auditor:
//
ApplicationMgr.DLLs   += {"GaudiAlg","GaudiAud"};
ApplicationMgr.ExtSvc += {"ChronoStatSvc"};

AuditorSvc.Auditors = {"ChronoAuditor"};


//
// Set up basic event loop: 
//
ApplicationMgr.ExtSvc = {"EventSelector/EventSelector" };
EventPersistencySvc.CnvServices = {"EventCnvSvc"};
EventSelector.Input = "SVC='DbEvtSelector";
EventSelector.PrintFreq = -1;



//
// A structure for the topalg, using sequencer steps:
//
ApplicationMgr.TopAlg = {"Sequencer/Top"};


//
// Define the top sequence loop:
//
Top.Members = {"Sequencer/Digitization",
               "Sequencer/Calibration",
               "Sequencer/Integrity",
               "Sequencer/Output",
               "Sequencer/NtupleMaker" };


//
// Needed for EventIntegrityAlg sequence breaking:
//
Top.StopOverride = true;


//
// Digitization sequence: Read in digis from a ROOT file
//
Digitization.Members = {"digiRootReaderAlg"};


//
// This needs to run after having read in the digis 
// so we can get the event time form them!
// Note: this is the opposite of what is needed for the MC!
//
Calibration.Members = {"TkrCalibAlg"};



//
// Using EventIntegrityAlg to decide if we run or skip recon: 
//     If the event passes, proceed as normal.
//     If EventIntegrityAlg is BAD, skip recon but output to file.
//
ApplicationMgr.DLLs += {"EventIntegrity"};
Integrity.Members    = {"EventIntegrityAlg",
                        "Sequencer/Filter",
                        "Sequencer/Reconstruction"};



//
// Detector services:
//
ApplicationMgr.DLLs   += {"GlastSvc"};
ApplicationMgr.ExtSvc += {"GlastDetSvc"};

GlastDetSvc.topVolume   = "LAT"; 
GlastDetSvc.visitorMode = "recon";



//
// Randoms definition:
//
ApplicationMgr.ExtSvc += {"GlastRandomSvc"};



//
// G4:
//
ApplicationMgr.DLLs   += {"G4Generator","G4Propagator"};
//ApplicationMgr.ExtSvc += {"G4GeometrySvc"};


//
// CAL Xtal respons::
//
ApplicationMgr.DLLs += {"CalXtalResponse"};
#include "$CALXTALRESPONSEROOT/src/defaultOptions.txt"

//
// Propagator:
//
ApplicationMgr.ExtSvc += {"GlastPropagatorSvc"};

 
//
// Reconstruction:
//
ApplicationMgr.DLLs += { "TkrUtil",
                        "CalRecon",
                        "TkrRecon"};

Reconstruction.Members = {"Sequencer/Cal1", 
                          "Sequencer/Tkr",
                          "Sequencer/Cal2",
                          "Sequencer/TkrIter",
                          "Sequencer/Acd"};


//
// Recon members:
//
Cal1.Members = {"CalXtalRecAlg",
                "CalClustersAlg/first",
                "CalEventEnergyAlg/RawEnergy"};
Cal2.Members = {"CalEventEnergyAlg/second"};


Tkr.Members     = {"TkrReconAlg/FirstPass"};
TkrIter.Members = {"TkrReconAlg/Iteration"};


//
// Decrease output:
//
second.OutputLevel = 5;  


//
// ACD recon:
//
ApplicationMgr.DLLs += {"AcdUtil", "AcdRecon"};
Acd.Members = {"AcdReconAlg"};

ApplicationMgr.DLLs  += { "EbfWriter", "OnboardFilter"};
// EbfWriter can fail on test data - such as four tower data
// OBF needs EBF - as of 06282007 mem leak if obf runs by itself
//Filter.Members       += {"EbfWriter", "OnboardFilter", "Count/downlink"}; // this guy can cause rejection
OnboardFilter.mask=0; // all bits off by default: no rejection
Reconstruction.Members += {"FilterTracks", "FilterAlg" }; //study performance


// Merit and AnalysisNtuple:
ApplicationMgr.DLLs += {"FluxSvc"}; // fo McValsTool
ApplicationMgr.DLLs   += {"AnalysisNtuple","ntupleWriterSvc","merit",
"GlastClassify"};
ApplicationMgr.ExtSvc += {"RootTupleSvc"};
NtupleMaker.Members += {"AnalysisNtupleAlg"}; // AnaTup and Filter in tuple
AnalysisNtupleAlg.tupleName = "MeritTuple";
NtupleMaker.Members += {"ClassifyAlg"}; // Atwood's Insightful Miner
NtupleMaker.Members += {"FT1Alg"}; // generate stuff for FT1
NtupleMaker.Members += {"meritAlg"}; // analysis for PSF
NtupleMaker.Members += {"McCoordsAlg", "ObfCoordsAlg" };

//
// Define the output sequence:
//
Output.Members = {"FhSetAlg","reconRootWriterAlg"};
Output.Members += {"CalTupleAlg"};

//ClassifyAlg.xmlFileName="DC2_Analysis.xml"; Do we still want to set this?

//
// Tracker geometry services:
//
ApplicationMgr.ExtSvc += {"TkrGeometrySvc"};
ApplicationMgr.ExtSvc += {"TkrInitSvc"};

// this fixes a HE track pattern recognition problem
// *** it should be done in TkrRecon ***
TkrFilterFirst.FilterToolName="TkrCalFilterTool";

//
// Calibrations:
//
#include "$GLEAMROOT/src/jobOptions/pipeline/calibrations.txt"


//
// Start up a CalFailureModeSvc:
//
ApplicationMgr.ExtSvc += {"CalFailureModeSvc"};




//
// Merit configuration: Disable IM variables
//
//MeritAlg.IM_filename = ""; 
//MeritAlg.cuts        = "LnA";


//
// Always fill ntuples:
//
RootTupleSvc.RejectIfBad = false;


// 
// Root IO:
//
ApplicationMgr.DLLs   += {"RootIo"};
ApplicationMgr.ExtSvc += {"RootIoSvc"}; 


//
// Must use RootIo as executable, not Gaudi event loop!
//
ApplicationMgr.Runable = "RootIoSvc"; 
 

//
// The following things can be changed by the user:
//


// 
// Set output level threshold:
//  2=DEBUG, 3=INFO, 4=WARNING, 5=ERROR, 6=FATAL
//
MessageSvc.OutputLevel = 3;


// 
// Number of events:
//
ApplicationMgr.EvtMax = 10000000000;


//
// Geometry:
//
GlastDetSvc.xmlfile = "$(XMLGEODBSROOT)/xml/latAssembly/latAssemblySegVols.xml";


//
// Name of input digi Root file:
//
digiRootReaderAlg.digiRootFileList = { "digi.root" } ;


//
// Name of output Merit Root file:
//
RootTupleSvc.filename = "merit.root";


//
// Name of output recon Root file:
//
reconRootWriterAlg.reconRootFile = "recon.root";


//
// Name of output CAL ntuple:
//
CalTupleAlg.tupleFilename = "caltuple.root";

//
// The Doors .....
//

//
// Job Option file for readigi_runrecon:
// Read in a digi Root file and run recon on it!
//

//
// Things to be changed by the user can 
// be found at the end of the file!
//



//
// Primary DLLs, including auditor:
//
ApplicationMgr.DLLs   += {"GaudiAlg","GaudiAud"};
ApplicationMgr.ExtSvc += {"ChronoStatSvc"};

AuditorSvc.Auditors = {"ChronoAuditor"};


//
// Set up basic event loop: 
//
ApplicationMgr.ExtSvc = {"EventSelector/EventSelector" };

EventPersistencySvc.CnvServices = {"EventCnvSvc"};

EventSelector.Input     = "SVC='DbEvtSelector";
EventSelector.PrintFreq = -1;


//
// A structure for the topalg, using sequencer steps:
//
ApplicationMgr.TopAlg = {"Sequencer/Top"};


//
// Define the top sequence loop:
//
Top.Members = {"Sequencer/Digitization",
               "Sequencer/Calibration",
               "Sequencer/Integrity",
               "Sequencer/Output",
               "Sequencer/NtupleMaker" };


//
// Needed for EventIntegrityAlg sequence breaking:
//
Top.StopOverride = true;


//
// Digitization sequence: Read in digis from a ROOT file!
//
Digitization.Members +={"digiRootReaderAlg"};

//
// This needs to run after having read in the digis 
// so we can get the event time from them!
// Note: this is the opposite of what is needed for the MC!
//
Calibration.Members = {"TkrCalibAlg","TkrCalibAlg/TkrReconCalib"};

//
// Using EventIntegrityAlg to decide if we run or skip recon: 
//     If the event passes, proceed as normal.
//     If EventIntegrityAlg is BAD, skip recon but output to file.
//
ApplicationMgr.DLLs += {"EventIntegrity"};

Integrity.Members    = {"EventIntegrityAlg",
                        "Sequencer/Filter",
                        "Sequencer/Reconstruction"};



//
// Detector services:
//
ApplicationMgr.DLLs   += {"GlastSvc"};
ApplicationMgr.ExtSvc += {"GlastDetSvc"};

GlastDetSvc.topVolume   = "LAT"; 
GlastDetSvc.visitorMode = "recon";



//
// Randoms definition:
//
ApplicationMgr.ExtSvc += {"GlastRandomSvc"};



//
// G4:
//
ApplicationMgr.DLLs += {"G4Generator","G4Propagator"};


//
// CAL Xtal respons::
//
ApplicationMgr.DLLs += {"CalXtalResponse"};


//
// Propagator:
//
ApplicationMgr.ExtSvc += {"GlastPropagatorSvc"};

 
//
// Reconstruction:
//
ApplicationMgr.DLLs += {"TkrUtil",
                        "CalRecon",
                        "TkrRecon"};

Reconstruction.Members = {"Sequencer/Cal1", 
                          "Sequencer/Tkr",
                          "Sequencer/Cal2",
                          "Sequencer/TkrIter",
                          "Sequencer/Acd",
                          "Sequencer/Cal3"};


//
// Recon members:
//
Cal1.Members = {"CalXtalRecAlg",
                "CalClustersAlg/first",
                "CalEventEnergyAlg/RawEnergy"};
Cal2.Members = {"CalEventEnergyAlg/second"};
Cal3.Members = {"GcrReconAlg","GcrSelectAlg"};

Tkr.Members     = {"TkrReconAlg/FirstPass"};
TkrIter.Members = {"TkrReconAlg/Iteration"};


//
// GCR:
//
ApplicationMgr.DLLs += {"GCRCalib"};

// New:
GcrReconAlg.HFC_Or_TriggerEng4 = "ANYFILTER";
GcrReconAlg.InitAxis           = "TKR";

// Old:
//GcrReconAlg.UseMcDir           = false;
//GcrReconAlg.HFC_Or_TriggerEng4 = "HFC";


//
// Decrease output:
//
second.OutputLevel = 5;  


//
// ACD recon:
//
ApplicationMgr.DLLs += {"AcdUtil", "AcdRecon"};
Acd.Members          = {"AcdReconAlg"};


//
// Merit and AnalysisNtuple:
//
ApplicationMgr.DLLs   += {"AnalysisNtuple","ntupleWriterSvc","GlastClassify"};
ApplicationMgr.ExtSvc += {"RootTupleSvc"};

//
// For dealing with non-MC data:
//
AnalysisNtupleAlg.toolList = {"McKludge","Glt","Acd","TkrHit","Tkr","Vtx","Cal","Evt","Obf"};


//
// FT2:
//
NtupleMaker.Members += {"PtValsAlg"}; 

PtValsAlg.PointingHistory = {"FT2_Gleam.fits", "", ""};


//
// Make ntuple:
//
NtupleMaker.Members += {"AnalysisNtupleAlg"}; 

//
// Name of ntuple:
//
AnalysisNtupleAlg.tupleName = "MeritTuple";

//
// Other members of ntuple:
//
NtupleMaker.Members += {"ClassifyAlg"}; 
NtupleMaker.Members += {"FT1Alg"}; 
NtupleMaker.Members += {"ObfCoordsAlg"};

//
// Define the output sequence:
//
Output.Members  = {"FhSetAlg","reconRootWriterAlg"};
Output.Members += {"CalTupleAlg"};
Output.Members += {"gcrSelectRootWriterAlg"};


//
// Tracker geometry services:
//
ApplicationMgr.ExtSvc += {"TkrGeometrySvc"};
ApplicationMgr.ExtSvc += {"TkrInitSvc"};

//
// This fixes a HE track pattern recognition problem
// *** it should be done in TkrRecon ***
//
TkrFilterFirst.FilterToolName = "TkrCalFilterTool";


//
// Calibrations:
//
#include "$GLEAMROOT/src/jobOptions/pipeline/calibrations.txt"


//
// Start up a CalFailureModeSvc:
//
ApplicationMgr.ExtSvc += {"CalFailureModeSvc"};


//
// Always fill ntuples:
//
RootTupleSvc.RejectIfBad = false;


// 
// Root IO:
//
ApplicationMgr.DLLs   += {"RootIo"};
ApplicationMgr.ExtSvc += {"RootIoSvc"}; 


//
// Must use RootIo as executable, not Gaudi event loop!
//
ApplicationMgr.Runable = "RootIoSvc"; 
 


//
// The following things can be changed by the user:
//


// 
// Set output level threshold:
//  2=DEBUG, 3=INFO, 4=WARNING, 5=ERROR, 6=FATAL
//
MessageSvc.OutputLevel = 3;


//
// TKR output:
//
TkrAlignmentSvc.OutputLevel = 4;
TkrGeometrySvc.OutputLevel  = 4;
TkrBadStripsSvc.OutputLevel = 4;

//
// GCR Output level:
//
GcrReconAlg.OutputLevel           = 4;
GcrReconSelect.OutputLevel        = 4;
GcrSelectAlg.OutputLevel          = 4;
ToolSvc.GcrReconTool.OutputLevel  = 4; 
ToolSvc.GcrSelectTool.OutputLevel = 4; 


// 
// Number of events:
//
ApplicationMgr.EvtMax = 10000000000;


//
// Geometry: Use flight geometry!
//
GlastDetSvc.xmlfile = "$(XMLGEODBSROOT)/xml/flight/flightSegVols.xml";


//
// Name of input digi Root file:
//
digiRootReaderAlg.digiRootFileList = {"digi.root"};


//
// Name of output Merit Root file:
//
RootTupleSvc.filename = "merit.root";


//
// Name of output recon Root file:
//
reconRootWriterAlg.reconRootFile = "recon.root";


//
// Name of output CAL ntuple:
//
CalTupleAlg.tupleFilename = "caltuple.root";


//
// Name of GCR Root file:
//
gcrSelectRootWriterAlg.gcrSelectRootFile = "gcr.root";


//
// The Doors .....
//

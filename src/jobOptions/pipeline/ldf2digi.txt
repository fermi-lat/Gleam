//
// Job Option file for fits2digi/ldf2digi: 
//


//
// Things to be changed by the user can 
// be found at the end of the file!
//


//
// Primary DLLs, including auditor: 
//
ApplicationMgr.DLLs   += {"GaudiAlg",
                          "GaudiAud"};
ApplicationMgr.DLLs   += {"MootSvc"};

ApplicationMgr.ExtSvc += {"ChronoStatSvc"};
ApplicationMgr.ExtSvc += {"MootSvc"};

AuditorSvc.Auditors    = {"ChronoAuditor"};


//
// A structure for the topalg, using sequencer steps:
//
ApplicationMgr.TopAlg = {"Sequencer/Top"};


//
// Define the top sequence loop:
//
Top.Members = {"Sequencer/Triggered"};


//
// Define the Triggered sequence:
//
Triggered.Members = {"Sequencer/Trigger",
                     "Sequencer/Output"};


//
// Services:
//
ApplicationMgr.DLLs   += {"GlastSvc"};
ApplicationMgr.ExtSvc += {"GlastDetSvc"};

ApplicationMgr.DLLs   += {"MootSvc","ConfigSvc"};
ApplicationMgr.ExtSvc += {"MootSvc","ConfigSvc"};

GlastDetSvc.topVolume   = "LAT"; 
GlastDetSvc.visitorMode = "recon";

// Allow MootSvc to continue if it can't find the MootKey
MootSvc.ExitOnFatal = false;


//
// Define the Trigger sequence:
//
ApplicationMgr.DLLs   += {"Trigger"};
Trigger.Members        = {"TriggerAlg","TriRowBitsAlg"};
ApplicationMgr.ExtSvc += {"LivetimeSvc"};
LivetimeSvc.Deadtime   = 0; // disable this for real data!


//
// Trigger mask: Accept all events!
//
TriggerAlg.mask = 0; 


//
// Trigger engines: Not applying any prescales for real data!
//
TriggerAlg.engine = "ConfigSvc";


//
// Define the Output sequence:
//
ApplicationMgr.DLLs += {"RootIo"}; 
Output.Members       = {"FhSetAlg","digiRootWriterAlg"};

//
// Use the LDF converter service to read in LDF files:
//
ApplicationMgr.DLLs   += {"LdfConverter"};
ApplicationMgr.ExtSvc += {"LdfEventSelector/EventSelector","LdfCnvSvc/EventCnvSvc"};


//
// Services:
//
EventPersistencySvc.CnvServices = {"EventCnvSvc"};


//
// Instrument:
// 
EventSelector.Instrument = "LAT";


//
// Checking for GEM Conditions Summary Word == 0:
//
EventSelector.GemZeroCheck = 1;

//
// For new CAL Trigger:
//
ApplicationMgr.DLLs += {"CalXtalResponse"};

#include "$GLEAMROOT/src/jobOptions/pipeline/calibrations.txt"

//
// Start up a CalFailureModeSvc:
//
ApplicationMgr.ExtSvc += {"CalFailureModeSvc"};

//
// OBF:
//
ApplicationMgr.DLLs  += {"EbfWriter","OnboardFilter"};
Trigger.Members      += {"EbfWriter","OnboardFilter"};
OnboardFilter.mask    = 0; // Keep all events!                    

// Real calibrations for the gamma-filter:
OnboardFilter.FileNamePeds  = "cal_db_pedestals_flight";
OnboardFilter.FileNameGains = "cal_db_gains_flight";

// Correct DGN: Pre-scale factors are in $GLAST_EXT/rh9_gcc32/obf/B1-0-6/src/XFC_DB/src/DGN_gem.h
OnboardFilter.DgnConfig = "DGN_gem";

// MIP-filter:
OnboardFilter.MipConfig = "MIP_all_axis";


// Usually Gamma, HIP and DGN are in the accept decision on board.
// It doesn't make sense to rerun DGN on real data. And it doesn't work on data anyway.
// We might as well always run the MIP filter. It's additional information. 
// The order is defined in: OnboardFilterTds/vXXX/OnboardFilterTds/ObfFilterStatus.h
//                          GammaFilter=0,HIP,MIP,DGN.
//
OnboardFilter.FilterList = {0,1,2};

// Feed all events to the filters:
EbfWriter.ReqGemTrig = false;

//
// The following things can be changed by the user:
//


//
// Set output level threshold:
// 2=DEBUG, 3=INFO, 4=WARNING, 5=ERROR, 6=FATAL 
//
MessageSvc.OutputLevel = 3;


//
// Number of events:
//
ApplicationMgr.EvtMax = 1000000000;


//
// Geometry: Use flight geometry!
//
GlastDetSvc.xmlfile = "$(XMLGEODBSROOT)/xml/flight/flightSegVols.xml";



//
// fits2digi: Use 'LDFFILE' for ldf2digi 
//            and 'LDFFITS' for fits2digi!  
//
EventSelector.StorageType = "LDFFITS";


//
// Input Fits/LDF file:
//
EventSelector.FileName = "file.fits";


//
// Output ROOT digi file:
//
digiRootWriterAlg.digiRootFile = "digi.root";


//
// The Doors .....
//
